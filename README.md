<h2 align="center">Burndown</h2>

<p align="center">
  <img src="https://github.com/Capydev-jac/Projeto-Ignis/blob/main/images/burndown_grafico_2.PNG">
  <img src="https://github.com/Capydev-jac/Projeto-Ignis/blob/main/images/burndown_pontos_2.PNG">
</p>

<h2 align="center">📌2ª Sprint Backlog</h2>

| ID    | Requisito                        | Descrição                                            | Prioridade | User Story                                                                                      | Critérios de Aceitação (DoD)                                                                                                                                           | Definição de Pronto (DoR)                                                                                               |
|-------|-----------------------------------|------------------------------------------------------|------------|-------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| RF01  | Focos de calor por estado         | Permitir consulta dos focos de calor por estado.      | Alta       | Como usuário, quero visualizar os focos de calor por estado para entender onde há incêndios.    | ✅ O sistema deve permitir busca por estado. <br> ✅ Os dados sobre os focos de calor devem ser extraídos corretamente do banco Queimadas. <br> ✅ A exibição deve incluir tabelas, gráficos e mapas de cada estado. <br> ✅ O sistema deve ser responsivo. | 🔹 Banco de dados: Queimadas. <br> 🔹 Exibição: Tabelas, gráficos e mapa interativo. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF02  | Focos de calor por bioma          | Permitir consulta dos focos de calor por bioma.       | Alta       | Como usuário, quero visualizar os focos de calor por bioma para entender os impactos ambientais.  | ✅ Deve ser possível selecionar um bioma específico. <br> ✅ Os dados de focos de calor devem ser extraídos corretamente do banco Queimadas. <br> ✅ A exibição deve incluir gráficos e tabelas referentes a cada bioma. | 🔹 Banco de dados: Queimadas. <br> 🔹 Exibição: Gráficos interativos e tabelas. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF03  | Risco de fogo por estado          | Permitir consulta do risco de fogo por estado.        | Alta       | Como usuário, quero consultar o risco de fogo por estado para planejar ações preventivas.        | ✅ O sistema deve exibir informações detalhadas sobre risco de fogo por estado. <br> ✅ O site deve apresentar os filtros selecionados para consulta. | 🔹 Banco de dados: Queimadas. <br> 🔹 Exibição validada pela equipe. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF04  | Risco de fogo por bioma           | Permitir consulta do risco de fogo por bioma.         | Alta       | Como usuário, quero consultar o risco de fogo por bioma para avaliar padrões ambientais.         | ✅ A busca deve permitir selecionar um bioma específico. <br> ✅ A exibição deve incluir destaques no mapa e gráficos sobre o bioma selecionado (risco de fogo). | 🔹 Banco de dados validado. <br> 🔹 Exibição: Gráficos comparativos. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF05  | Área queimada por estado          | Permitir consulta da área queimada por estado.        | Média      | Como usuário, quero visualizar a área queimada por estado para compreender a extensão dos incêndios. | ✅ O sistema deve exibir os dados de área queimada corretamente. <br> ✅ Os dados devem ser validados pelo PO antes da implementação. <br> ✅ A exibição deve incluir, gráficos de área e tabelas baseado na consulta solicitada. | 🔹 Banco de dados estruturado. <br> 🔹 Exibição: Gráficos de área. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF06  | Área queimada por bioma           | Permitir consulta da área queimada por bioma.         | Média      | Como usuário, quero acessar dados da área queimada por bioma para entender os impactos.          | ✅ A busca deve permitir filtragem por bioma. <br> ✅ A exibição da área deve incluir gráficos e tabelas baseada na consulta por bioma. | 🔹 Banco de dados validado. <br> 🔹 Exibição: Gráficos interativos e tabelas. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF10  | Restringir consultas por tempo    | Permitir que o usuário filtre consultas por período de tempo. | Alta | Como usuário, quero filtrar os dados por período de tempo para análise específica.              | ✅ O sistema deve permitir seleção de intervalos de tempo para filtragem. <br> ✅ A funcionalidade deve ser testada para garantir funcionamento correto. <br> ✅ O banco de dados deve suportar os filtros temporais sem perda de desempenho. | 🔹 Regras de filtragem definidas pela equipe. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF11  | Análise de meses de risco de fogo | Permitir visualizar os meses com maior risco de fogo. | Alta | Como usuário, quero identificar os meses mais críticos para planejar ações preventivas.           | ✅ O sistema deve identificar corretamente os meses de maior risco com base no banco de dados Queimadas. <br> ✅ As informações das análises devem ser exibidas de forma clara e acessível. | 🔹 Banco de dados validado: Queimadas. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF12  | Análise de relação entre risco e área queimada | Permitir analisar se o risco de fogo está associado a áreas queimadas. | Alta | Como usuário, quero avaliar a correlação entre risco de fogo e áreas queimadas para melhorar previsões. | ✅ O sistema deve identificar corretamente a relação entre o risco e a área queimada com base nos dados filtrados do banco de dados Queimadas. <br> ✅ As informações entre o risco e a área queimada devem ser exibidas de forma clara e acessível. | 🔹 Cálculos estatísticos definidos e validados. <br> 🔹 Softwares: PostgreSQL, DB Designer. |
| RF13  | Diagramas UML                     | Criar diagramas de casos de uso, classes e sequência e de casos de teste.  | Alta | Como usuário, quero visualizar diagramas UML para entender melhor o funcionamento do sistema.      | ✅ Os diagramas devem ser criados utilizando Astah. <br> ✅ A modelagem deve seguir os requisitos validados pelo PO antes da implementação. <br> ✅ Os diagramas devem ser revisados pela equipe para garantir precisão. | 🔹 Requisitos levantados antes da modelagem UML. <br> 🔹 Softwares: Astah. |

<h2 align="center">Sprint Retrospective</h2>

<br>A equipe passou por uma evolução significativa ao longo de suas sprints, transformando-se de uma aplicação acadêmica inicial em uma solução robusta, modular, integrada e alinhada com padrões profissionais de desenvolvimento de sistemas full stack. Esta evolução foi marcada por melhorias técnicas e organizacionais que impactaram diretamente na qualidade, desempenho, escalabilidade e usabilidade do sistema.<br>

Inicialmente, a aplicação possuía uma estrutura simples e monolítica, com códigos concentrados em poucos arquivos, dificultando a manutenção, evolução e colaboração entre os membros da equipe. Com o avanço para a versão consolidada da equipe a arquitetura foi totalmente reestruturada de maneira modular e profissional, separando claramente frontend, backend, serviços, rotas, controllers e banco de dados. Essa organização facilitou tanto a manutenção quanto a escalabilidade, adotando padrões consagrados de arquitetura de software. <br>

Outra evolução importante foi a implementação de um backend real com Node.js e Express, substituindo os dados mockados por uma API completa com rotas RESTful, integradas a um banco PostgreSQL com extensão PostGIS. Isso permitiu consultas dinâmicas, seguras e estruturadas, viabilizando a manipulação de dados reais com confiabilidade e robustez, além de possibilitar consultas geoespaciais avançadas como áreas queimadas e focos de calor. <br>

No frontend, foi realizada a integração total com o backend, permitindo que os filtros aplicados na interface gerassem requisições reais para a API, retornando dados dinâmicos e relevantes de acordo com as seleções do usuário. Essa evolução eliminou a rigidez dos dados estáticos e trouxe mais dinamismo, eficiência e alinhamento com padrões modernos de consumo de APIs. <br>

Visualmente, o projeto evoluiu para uma interface mais moderna, intuitiva e responsiva, utilizando tecnologias como React, React Leaflet para mapas interativos e Google Charts para gráficos dinâmicos, além de uma preocupação maior com a experiência do usuário e a identidade visual do sistema.<br>

Em relação à performance, foram aplicadas práticas modernas de otimização como uso de hooks avançados (useMemo, useCallback), lazy loading de componentes pesados e eliminação de re-renders desnecessários. O uso de TypeScript foi fortalecido, trazendo segurança, previsibilidade e manutenção facilitada ao código.<br>

